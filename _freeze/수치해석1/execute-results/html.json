{
  "hash": "06b88625121081e452410d87a29ad754",
  "result": {
    "engine": "jupyter",
    "markdown": "# 수치해석학 Ch1 {.unnumbered}\n\n금융 수치해석의 소개\n\n## 강의 개요 : 금융수치해석의 필요성\n\n주로 파생상품 평가와 최적화 방법론에 대해서 다룰 예정\n\n### 파생상품 평가\n\n$ds=rSdt+\\sigma SdW^Q$\n\n기하학적 브라운운동을 따르는 기초자산에 대한 파생상품의 가격 $f(t,S)$는 아래의 PDE로 표현됨\n\n$f_t+\\frac{1}{2}\\sigma^2S^2f_{ss}+rSf_s-rf=0$\n\n이 블랙숄즈 미분방정식을 컴퓨터로 풀어내는 것이 주요 내용임\n\n여기에는 반드시 연속적인 수식을 이산화하는 과정이 필요하며, 다양한 수치해석적인 기법이 활용됨\n\n대표적으로 유한차분법(Finite Difference Method, FDM)이 존재\n\n### 최적화 방법론\n\n이외의 다양한 최적화방법론은 시간이 여유롭다면 이것저것 다룰 예정\n\n- Minimum Variance Portfolio : Single-period에 대해 Sharpe ratio 극대화 등\n- Stochastic programming : Multi-period에 대해 Minimum var 문제 해결 등\n- Non-convex optimization : 미분을 통해 극값을 산출할 수 없는 경우의 최적화\n- Parameter estimation 또는 Model calibration : $min_{\\theta,\\sigma,k}\\sum(model\\;price - market\\;price)^2$와 같은 문제 등\n\n## 컴퓨터 연산에 대한 이해\n\n수치해석기법을 사용할 때 필연적으로 오차(error) 발생\n\n1. Truncation error : 연속적인 수학적인 모델을 이산화하면서 발생하는 오차(e.g. 미분계수)\n\n2. Rounding error : 컴퓨터 시스템상 실수(real number)를 정확히 표현할 수 없는 데에서 기인(2진법 vs. 10진법)\n\n::: {#67113fa8 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\na = 0.1\n\nprint(a+a+a==0.3,a+a+a+a==0.4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse True\n```\n:::\n:::\n\n\n### Rounding error 관련\n\n컴퓨터가 실수를 나타내는 방법은 일반적으로 $x=\\pm n\\times b^e$로 나타냄.\n\n여기서 $n$은 가수, $e$는 지수이며, 일반적으로 밑인 $b$는 2를 사용함.\n\n컴퓨터에서 많이 사용하는 float타입 실수는 32bit를 사용하여 실수를 표현하며,\n\n이는 $2^32$가지로 모든 실수를 표현하게됨을 의미함. (정수는 int타입으로 모두 표현가능)\n\n따라서 소수점에 따라 정확한 값을 나타내지 못하는 문제는 항상 존재.\n\n#### Precision of floating point arithmetic\n\n실수표현의 정밀도는 $float(1+\\epsilon_{math})>1$이 되는 가장 작은 $\\epsilon_{math}$를 의미\n\n::: {#dc053bc1 .cell execution_count=2}\n``` {.python .cell-code}\ne = 1\nwhile 1 + e > 1:\n    e = e/2\ne_math = 2 * e\nprint(e_math)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n내장함수 활용 가능. 파이썬에서는 기본적으로 64bit double타입을 사용함\n\n::: {#b2a4bec7 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nprint(np.finfo(np.double).eps,\n      np.finfo(float).eps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.220446049250313e-16 2.220446049250313e-16\n```\n:::\n:::\n\n\n::: {#25220265 .cell execution_count=4}\n``` {.python .cell-code}\nprint(1+e, 1+e+e, 1+2*e, 1+1.0000001*e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0 1.0 1.0000000000000002 1.0000000000000002\n```\n:::\n:::\n\n\n많이 쓰이는 double타입의 경우 64bit로 실수를 표현하는데,\n\n$x=\\pm n\\times 2^e$에서 부호($\\pm$) 1자리, 가수($n$) 52자리, 지수 11자리($e$)를 의미\n\n## 계산오차\n\n절대오차 : $|{\\hat{x}-x}|$\n\n상대오차 : $\\frac{|{\\hat{x}-x}|}{|x|}$\n\n결합오차 : $e_{comb}=\\frac{|{\\hat{x}-x}|}{|x|+1}$\n\n### 유한차분을 이용한 도함수의 근사\n\n$$f'(x)=\\lim_{h\\rightarrow 0}\\frac{f(x+h)-f(x)}{h}$$\n\n컴퓨터로는 $h\\rightarrow 0$을 정확히 표현할 수 없음.\n\n따라서, 적당히 작은 값으로 이를 대체하여 $f'(x)$를 근사해야함.\n\n1. Truncation error 최소화를 위해서는 h는 작을 수록 좋음\n2. 그러나, 너무 작은 값을 선택하면 rounding error가 발생하여 $x=x+h$ 될 가능성\n\n#### Taylor expansion\n\n$$f(x)=\\sum_{k=0}^\\infty \\frac{f^{(k)}(x_0)}{k!}(x-x_0)^{k}=\\sum_{k=0}^n \\frac{f^{(k)}(x_0)}{k!}(x-x_0)^{k}+\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}$$\n\n이를 도함수에 적용하면,\n\n$$f(x+h)=f(x)+hf'(x)+\\frac{h^2}{2}f''(x)+\\frac{h^3}{3!}f'''(x)+\\dotsm+\\frac{h^n}{n!}f^{(n)}(x)+R_n(x+h)$$\n\n$n=1$을 적용하면,\n\n$\\Rightarrow\\;f(x+h)=f(x)+hf'(x)+\\frac{h^2}{2}f''(\\xi)\\;for\\;\\xi\\in[x,x+h]$\n\n$\\Rightarrow\\;f'(x)=\\frac{f(x+h)-f(x)}{h}-\\frac{h}{2}f''(\\xi)\\;(Forward\\;Approximation)$\n\n$n=2$를 적용하고 forward - backward를 정리하면,\n\n$f'(x)=\\frac{f(x+h)-f(x-h)}{h}-\\frac{h^2}{3}f'''(\\xi)\\;(Central\\;Difference\\;Approximation)$\n\n::: {.callout, title=\"Central Difference Approximation\"}\n$for\\;n=2,$\n\n$(Forward)\\;f(x+h)=f(x)+hf'(x)+\\frac{h^2}{2}f''(x)+\\frac{h^3}{3!}f'''(\\xi_+),\\;\\xi\\in[x,x+h]$\n\n$(Backward)\\;f(x-h)=f(x)-hf'(x)+\\frac{h^2}{2}f''(x)-\\frac{h^3}{3!}f'''(\\xi_-),\\;\\xi\\in[x-h,x]$\n\n$f(x+h)-f(x-h)=2hf'(x)+\\frac{h^2}{6}\\{f'''(\\xi_+)+f'''(\\xi_-)\\}$\n\n$\\Rightarrow\\;f'(x)=\\frac{f(x+h)-f(x-h)}{h}-\\frac{h^2}{3}f'''(\\xi),\\;\\xi\\in[x-h,x+h]$\n:::\n\n위의 식에서 볼 수 있는 것처럼, Central 방식에서는 truncation error의 order가 $h^2$이므로,\n\n다른 방식에 비해서 오차가 훨씬 줄어들게 됨\n\n유사한 방식으로 이계도함수와 편도함수를 유도하면,\n\n$f''(x)=\\frac{f(x+h)+f(x-h)-2f(x)}{h^2}-\\frac{h^2}{24}f^{(4)}(\\xi)$\n\n$f_x(x,y)=\\frac{f(x+h_x,y)-f(x-h_x,y)}{2h_x}+trunc.\\;error$\n\n### 총오차 및 최적의 h 산출\n\nForward difference approximation을 사용하고, $|f''(x)|<=M$이라고 하면,\n\n$|f_h'(x)-f'(x)|=\\frac{h}{2}|f''(x)|<=\\frac{h}{2}M\\;(trunc.\\;error)$\n\n유인물 참조\n\n총오차 최소화를 위한 $h^*$ 산출이 목표\n\n### 유한차분을 이용한 도함수 근사 예시\n\n$f(x)=cos(x^x)-sin(e^x)$\n\n***함수 및 도함수(analytic form) 정의 및 도식화***\n\n::: {#95bb6e42 .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np \nimport matplotlib.pyplot as plt \ndef fun(x):\n    return np.cos(x**x) - np.sin(np.exp(x))\n\ndef fprime(x):\n    return -np.sin(x**x)*(x**x)*(np.log(x)+1)  - np.cos(np.exp(x))*np.exp(x)\n\nx = np.linspace(0.5,2.5,101)\ny = fun(x)\nplt.plot(x,y,'-')\n```\n\n::: {.cell-output .cell-output-display}\n![](수치해석1_files/figure-html/cell-6-output-1.png){width=582 height=411}\n:::\n:::\n\n\n***미분계수 산출***\n\n::: {#9b1e3fb3 .cell execution_count=6}\n``` {.python .cell-code}\nx = 1.5\nd = fprime(x)\nprint(\"derivative = \", d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nderivative =  -1.466199173237208\n```\n:::\n:::\n\n\n***forward 및 central difference approx. 산출 및 비교, 총오차를 log scale로 표현***\n\ntrunc. error는 h가 작아질수록 감소하지만 특정구간 이후에는 rounding error가 발생하므로\n\n총오차는 항상 감소하지 않게 됨.\n\n최적 $h^*$를 찾는 것이 매우 중요함\n\n::: {#6313f353 .cell execution_count=7}\n``` {.python .cell-code}\np = np.linspace(1,16,151)\nh = 10**(-p)\n\ndef forward_difference(x,h):\n    return (fun(x+h)-fun(x)) / h\n\ndef central_difference(x,h):\n    return (fun(x+h)-fun(x-h)) / (2*h)\n\nfd = forward_difference(x, h)\ncd = central_difference(x, h)\nprint(\"forward = \", fd)\nprint(\"central = \", cd)\n\nfd_error = np.log(np.abs(fd-d)/np.abs(d))\ncd_error = np.log(np.abs(cd-d)/np.abs(d))\nplt.plot(p,fd_error, p, cd_error)\nplt.legend(['forward difference', 'central difference'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nforward =  [-2.62212289 -2.37366424 -2.17930621 -2.02733993 -1.90838758 -1.81511559\n -1.74184228 -1.68417626 -1.63872005 -1.60283855 -1.57448171 -1.55204964\n -1.53429022 -1.52022092 -1.50906909 -1.50022597 -1.49321118 -1.48764519\n -1.48322779 -1.47972134 -1.47693759 -1.47472735 -1.4729723  -1.4715786\n -1.47047179 -1.46959277 -1.46889464 -1.46834015 -1.46789975 -1.46754995\n -1.4672721  -1.46705142 -1.46687612 -1.46673689 -1.46662629 -1.46653844\n -1.46646866 -1.46641323 -1.46636921 -1.46633424 -1.46630646 -1.46628439\n -1.46626686 -1.46625294 -1.46624188 -1.4662331  -1.46622612 -1.46622058\n -1.46621618 -1.46621268 -1.4662099  -1.4662077  -1.46620594 -1.46620455\n -1.46620344 -1.46620257 -1.46620187 -1.46620131 -1.46620087 -1.46620053\n -1.46620025 -1.46620002 -1.46619985 -1.46619971 -1.46619959 -1.46619951\n -1.46619944 -1.46619939 -1.46619934 -1.46619931 -1.46619927 -1.46619923\n -1.46619922 -1.46619918 -1.46619921 -1.46619915 -1.46619915 -1.46619919\n -1.46619909 -1.46619907 -1.46619916 -1.46619915 -1.46619876 -1.46619938\n -1.46619893 -1.46619919 -1.46619932 -1.46619869 -1.46619769 -1.4662003\n -1.46619716 -1.46619985 -1.46619876 -1.46620071 -1.46619865 -1.46619427\n -1.46619269 -1.46620314 -1.46618158 -1.46619854 -1.46618273 -1.46617469\n -1.46619173 -1.46614311 -1.46615961 -1.46626449 -1.46620595 -1.46619201\n -1.46615356 -1.46621617 -1.46616053 -1.46617469 -1.46608615 -1.46578868\n -1.46632693 -1.46612406 -1.46518938 -1.46619201 -1.46545305 -1.46568705\n -1.46438417 -1.46757238 -1.46221506 -1.46202287 -1.46130718 -1.46050672\n -1.45413969 -1.46897416 -1.45004198 -1.46392328 -1.44328993 -1.4535955\n -1.40766793 -1.46202287 -1.39437708 -1.40433339 -1.32596324 -1.44671698\n -1.40100674 -1.41101039 -1.66533454 -1.39768798 -1.05575095 -0.88607446\n -1.11550166 -0.70216669 -0.88397549 -1.11285921 -1.40100674 -1.76376299\n  0.        ]\ncentral =  [-1.5635526  -1.52856423 -1.50592274 -1.49141188 -1.48216656 -1.4762975\n -1.47258018 -1.47022905 -1.46874334 -1.46780503 -1.46721263 -1.46683872\n -1.46660274 -1.46645382 -1.46635985 -1.46630056 -1.46626314 -1.46623954\n -1.46622464 -1.46621524 -1.46620931 -1.46620557 -1.46620321 -1.46620172\n -1.46620078 -1.46620019 -1.46619981 -1.46619958 -1.46619943 -1.46619933\n -1.46619927 -1.46619924 -1.46619921 -1.4661992  -1.46619919 -1.46619918\n -1.46619918 -1.46619918 -1.46619918 -1.46619917 -1.46619917 -1.46619917\n -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917\n -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917\n -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917\n -1.46619918 -1.46619917 -1.46619917 -1.46619917 -1.46619917 -1.46619917\n -1.46619917 -1.46619917 -1.46619918 -1.46619918 -1.46619917 -1.46619916\n -1.46619918 -1.46619915 -1.46619918 -1.46619915 -1.46619923 -1.46619922\n -1.46619909 -1.46619924 -1.46619938 -1.46619908 -1.46619894 -1.46619938\n -1.46619879 -1.46619919 -1.4661991  -1.46619925 -1.46619804 -1.46620118\n -1.46619883 -1.46620125 -1.46619876 -1.46620071 -1.46620423 -1.46619603\n -1.4661949  -1.46620592 -1.46619208 -1.46620736 -1.46619383 -1.46617469\n -1.46620932 -1.46616527 -1.4661875  -1.46626449 -1.46622805 -1.46619201\n -1.46629366 -1.46630436 -1.46638257 -1.46624457 -1.46626211 -1.46612096\n -1.46632693 -1.4662996  -1.46585236 -1.46647023 -1.46615356 -1.46612799\n -1.46493928 -1.46827122 -1.46485444 -1.46645324 -1.46409593 -1.46401756\n -1.4607695  -1.47732061 -1.46054953 -1.46392328 -1.45439216 -1.46757238\n -1.44285963 -1.50632659 -1.45015216 -1.43944172 -1.41436079 -1.50235994\n -1.40100674 -1.58738669 -1.72084569 -1.67722557 -1.40766793 -1.10759308\n -1.39437708 -1.05325004 -1.32596324 -1.66928882 -2.10151011 -2.64564449\n  0.        ]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](수치해석1_files/figure-html/cell-8-output-2.png){width=577 height=411}\n:::\n:::\n\n\n## 수치적 불안정성과 악조건\n\n수치적 불안정성 : 알고리즘이 rounding error를 증폭시켜 결과값이 크게 달라짐\n\n악조건 : input data의 작은 변동이 output solution에 큰 변화를 일으킴\n\n### 행렬의 조건수\n\n문제 f(x)의 해가 x(input)에 얼마나 영향을 받는지 나타내는 값\n\n탄력성의 절대값 : $cond(f(x))\\approx\\frac{|xf'(x)|}{|f(x)|}$\n\n탄력성의 절대값이 크면 악조건임\n\nLinear system에서 행렬의 조건수 $k(A)=||A^{-1}||\\;||A||$\n\n$조건수>1/\\sqrt{eps}\\approx 6.7\\times 10^7$이면 약조건 우려\n\n## 알고리즘의 계산 복잡도\n\n실행시간을 많이 다룰거임.\n\n### 알고리즘 복잡도\n\norder가 중요함\n\nbig-O를 표현식으로 쓰는데, 계산효율성이나 오차크기를 나타낼때 씀\n\n$O(n^2)$ : 데이터를 10배 늘리면 계산이 100배 늘어남\n\n$O(n^{-2})$ : 데이터를 10배 늘리면 오차가 100배 감소함\n\n",
    "supporting": [
      "수치해석1_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}